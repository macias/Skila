using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using NaiveLanguageTools.Common;
using Skila.Language.Semantics;

namespace Skila.Language
{
    [DebuggerDisplay("{GetType().Name} {ToString()}")]
    public sealed class EntityModifier : Node, IValidable
    {
        private enum ModifierIndex
        {
            Static,
            Implicit,
            HeapOnly,
            Public,
            Private,
            Reassignable, // "var x ..."
            //InOut // for parameters only, reassignment is visible outside function
            Mutable, // to allow (deeply) mutable types, used when defining types
            Const, // reverse of "Mutable", used in constraints
            Base, // unseal types
            Interface,
            Protocol, // same as interface, but supports duck type matching 
            Trait, // container for additional methods for a type (it is NOT like C# extension)
            Override, // modifier for methods ("override" in C#)
            Abstract,
            Protected,
            UnchainBase, // despite we derive base function we won't call it
            Native, // info for compiler whether to call real function or use low-evel instruction
            Enum,
            Pinned,
            Final,
            AssociatedReference,
            AutoGenerated,
            This, // for type extensions (like in C#)
            Accessor, // getter/setter of the property
            PostInitialization, // allowing readonly member initialization in post-initialization (object-initialization in C#)
            Value, // type without pointers and references
        }

        private static readonly int enum_count = EnumExtensions.GetValues<ModifierIndex>().Count();

        public static EntityModifier None { get; } = new EntityModifier();
        public static EntityModifier Static { get; } = new EntityModifier(ModifierIndex.Static);
        public static EntityModifier Implicit { get; } = new EntityModifier(ModifierIndex.Implicit);
        public static EntityModifier HeapOnly { get; } = new EntityModifier(ModifierIndex.HeapOnly);
        public static EntityModifier Public { get; } = new EntityModifier(ModifierIndex.Public);
        public static EntityModifier Private { get; } = new EntityModifier(ModifierIndex.Private);
        public static EntityModifier Reassignable { get; } = new EntityModifier(ModifierIndex.Reassignable);
        public static EntityModifier Mutable { get; } = new EntityModifier(ModifierIndex.Mutable);
        public static EntityModifier Base { get; } = new EntityModifier(ModifierIndex.Base);
        public static EntityModifier Interface { get; } = new EntityModifier(ModifierIndex.Interface);
        public static EntityModifier Protocol { get; } = new EntityModifier(ModifierIndex.Protocol);
        public static EntityModifier Trait { get; } = new EntityModifier(ModifierIndex.Trait);
        public static EntityModifier Override { get; } = new EntityModifier(ModifierIndex.Override);
        public static EntityModifier Abstract { get; } = new EntityModifier(ModifierIndex.Abstract);
        public static EntityModifier Const { get; } = new EntityModifier(ModifierIndex.Const);
        public static EntityModifier Protected { get; } = new EntityModifier(ModifierIndex.Protected);
        public static EntityModifier UnchainBase { get; } = new EntityModifier(ModifierIndex.UnchainBase);
        public static EntityModifier Native { get; } = new EntityModifier(ModifierIndex.Native);
        public static EntityModifier Enum { get; } = new EntityModifier(ModifierIndex.Enum);
        public static EntityModifier Pinned { get; } = new EntityModifier(ModifierIndex.Pinned);
        public static EntityModifier Final { get; } = new EntityModifier(ModifierIndex.Final);
        public static EntityModifier AssociatedReference { get; } = new EntityModifier(ModifierIndex.AssociatedReference);
        public static EntityModifier AutoGenerated { get; } = new EntityModifier(ModifierIndex.AutoGenerated);
        public static EntityModifier This { get; } = new EntityModifier(ModifierIndex.This);
        public static EntityModifier Accessor { get; } = new EntityModifier(ModifierIndex.Accessor);
        public static EntityModifier PostInitialization { get; } = new EntityModifier(ModifierIndex.PostInitialization);
        public static EntityModifier Value { get; } = new EntityModifier(ModifierIndex.Value);

        private readonly int[] flags; // value tells how many times given modifier was specified

        public bool HasAny => this.flags.Any(it => it > 0);
        public bool HasStatic => this.flags[(int)ModifierIndex.Static] > 0;
        public bool HasImplicit => this.flags[(int)ModifierIndex.Implicit] > 0;
        public bool HasHeapOnly => this.flags[(int)ModifierIndex.HeapOnly] > 0;
        public bool HasPublic => this.flags[(int)ModifierIndex.Public] > 0;
        public bool HasPrivate => this.flags[(int)ModifierIndex.Private] > 0;
        public bool HasReassignable => this.flags[(int)ModifierIndex.Reassignable] > 0;
        public bool HasMutable => this.flags[(int)ModifierIndex.Mutable] > 0;
        public bool HasConst => this.flags[(int)ModifierIndex.Const] > 0;
        public bool HasBase => this.flags[(int)ModifierIndex.Base] > 0;
        public bool HasInterface => this.flags[(int)ModifierIndex.Interface] > 0;
        public bool HasProtocol => this.flags[(int)ModifierIndex.Protocol] > 0;
        public bool HasTrait => this.flags[(int)ModifierIndex.Trait] > 0;
        public bool HasOverride => this.flags[(int)ModifierIndex.Override] > 0;
        public bool HasAbstract => this.flags[(int)ModifierIndex.Abstract] > 0;
        public bool HasProtected => this.flags[(int)ModifierIndex.Protected] > 0;
        public bool HasUnchainBase => this.flags[(int)ModifierIndex.UnchainBase] > 0;
        public bool HasNative => this.flags[(int)ModifierIndex.Native] > 0;
        public bool HasEnum => this.flags[(int)ModifierIndex.Enum] > 0;
        public bool HasPinned => this.flags[(int)ModifierIndex.Pinned] > 0;
        public bool HasFinal => this.flags[(int)ModifierIndex.Final] > 0;
        public bool HasAssociatedReference => this.flags[(int)ModifierIndex.AssociatedReference] > 0;
        public bool HasAutoGenerated => this.flags[(int)ModifierIndex.AutoGenerated] > 0;
        public bool HasThis => this.flags[(int)ModifierIndex.This] > 0;
        public bool HasAccessor => this.flags[(int)ModifierIndex.Accessor] > 0;
        public bool HasPostInitialization => this.flags[(int)ModifierIndex.PostInitialization] > 0;
        public bool HasValue => this.flags[(int)ModifierIndex.Value] > 0;


        public bool IsSealed => (!this.HasInterface // makes sense only for types
                                 && !this.IsPolymorphic)
                                || this.HasFinal;

        public bool IsPolymorphic => this.HasOverride || this.HasBase || this.HasAbstract || this.HasPinned;
        public bool IsAccessSet => this.HasPublic || this.HasPrivate || this.HasProtected;
        public bool IsAbstract => this.HasInterface || this.HasProtocol || this.HasAbstract;
        public bool RequiresOverride => this.IsAbstract || (this.HasPinned && !this.HasFinal);

        public override IEnumerable<INode> ChildrenNodes { get { yield break; } }

        public EntityModifier AccessLevels
        {
            get
            {
                EntityModifier mod = EntityModifier.None;
                if (this.HasPublic)
                    mod |= EntityModifier.Public;
                if (this.HasProtected)
                    mod |= EntityModifier.Protected;
                if (this.HasPrivate)
                    mod |= EntityModifier.Private;
                return mod;
            }
        }

        private EntityModifier()
        {
            this.flags = new int[enum_count];
        }
        private EntityModifier(ModifierIndex index) : this()
        {
            ++this.flags[(int)index];
        }

        private EntityModifier(EntityModifier modifierA,EntityModifier modifierB) : this()
        {
            for (int i = 0; i < flags.Length; ++i)
            {
                this.flags[i] = modifierA.flags[i]+ modifierB.flags[i];
            }
        }

        public override string ToString()
        {
            return Enumerable.Range(0, enum_count).Select(idx =>
             {
                 int count = flags[idx];
                 if (count == 0)
                     return null;
                 string s = ((ModifierIndex)idx).ToString().ToLowerInvariant();
                 if (count > 1)
                     s += $"({count})";
                 return s;
             })
            .Where(it => it != null)
            .Join(" ");
        }

        public static EntityModifier operator |(EntityModifier a, EntityModifier b)
        {
            if (b == null || b == EntityModifier.None)
                return a;
            else if (a == null || a == EntityModifier.None)
                return b;
            else
                return new EntityModifier(a, b);
        }

        public bool Has(EntityModifier modifier)
        {
            int count = enum_count;
            for (int i = 0; i < count; ++i)
                if (modifier.flags[i] > 0 && this.flags[i] == 0)
                    return false;

            return true;
        }

        internal bool SameAccess(EntityModifier other)
        {
            return this.HasPublic == other.HasPublic
                && this.HasProtected == other.HasProtected
                && this.HasPrivate == other.HasPrivate;
        }

        public void Validate(ComputationContext ctx)
        {
            if (this.HasConst && this.HasMutable)
                ctx.AddError(ErrorCode.ConflictingModifier, this);

            if (!ctx.Env.Options.AllowProtocols && this.HasProtocol)
                ctx.AddError(ErrorCode.DisabledProtocols, this);
        }
    }

}
